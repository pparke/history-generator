'use strict';

let Canvas              = require('canvas');
let fs                  = require('fs');

let Image   = Canvas.Image;

class Display {
  constructor (outdir, imageName) {

    this.outdir = outdir;
    this.imageName = imageName;

    this.palettes = {
      terrain: [
        {r: 34, g: 32, b: 52, a: 255},
        {r: 63, g: 63, b: 116, a: 255},
        {r: 48, g: 96, b: 130, a: 255},
        {r: 91, g: 110, b: 225, a: 255},
        {r: 99, g: 155, b: 255, a: 255},
        {r: 255, g: 211, b: 92, a: 255},
        {r: 138, g: 111, b: 48, a: 255},
        {r: 75, g: 105, b: 47, a: 255},
        {r: 106, g: 190, b: 48, a: 255},
        {r: 143, g: 151, b: 74, a: 255},
        {r: 82, g: 75, b: 36, a: 255},
        {r: 102, g: 57, b: 49, a: 255},
        {r: 143, g: 86, b: 59, a: 255},
        {r: 89, g: 86, b: 82, a: 255},
        {r: 155, g: 173, b: 183, a: 255},
        {r: 255, g: 255, b: 255, a: 255}
      ],

      temp: [
        {r: 201, g: 79, b: 166, a: 100},
        {r: 134, g: 0, b: 131, a: 100},
        {r: 32, g: 1, b: 141, a: 100},
        {r: 1, g: 137, b: 255, a: 100},
        {r: 254, g: 255, b: 3, a: 100},
        {r: 255, g: 119, b: 1, a: 100},
        {r: 255, g: 12, b: 0, a: 100},
        {r: 122, g: 0, b: 1, a: 100}
      ]
    };

    this.stops = {
      temp: [
        {R: 0, g: 1, B: 255, a: 255},
        {R: 0, G: 255, b: -1, a: 255},
        {r: 1, G: 255, B: 0, a: 255},
        {R: 255, g: -1, B: 0, a: 255}
      ]
    }
  }

  /**
   * Draw overlay images for the grid
   */
  overlay () {

  }

  /**
   * Render a grid as an image
   * used for per pixel rendering
   */
  render (grid, fileName, options) {
    fileName        = fileName || this.imgName;
    let width       = grid.length;
    let height      = grid[0].length;
    options         = options || {};
    let renderStyle = options.renderStyle || 'palette';
    let renderKey   = options.renderKey || 'terrain';

    let renderFn;
    if (renderStyle === 'palette') {
      renderFn = this.paletteBrush.bind(this, renderKey);
    }
    else if (renderStyle === 'gradient') {
      renderFn = this.gradBrush.bind(this, renderKey);
    }
    else if (renderStyle === 'hsl') {
      renderFn = this.hslBrush.bind(this);
    }

    // create a new canvas to render to
    let canvas = new Canvas(width, height);
    let ctx = canvas.getContext('2d');

    // set background color
    ctx.rect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'rgb(0, 0, 255)';
    ctx.fill();

    // get the ImageData object
    let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    let imgDD     = imageData.data;

    // draw each pixel according to the height value
    grid.forEach((col, x) => {
      col.forEach((elem, y) => {
        let color = renderFn(elem);
        this.setPixel(imgDD, imageData.width, x, y, color);
      });
    });

    // save the changes to the context
    ctx.putImageData(imageData, 0, 0);

    // Write image buffer to disk
    let out = fs.createWriteStream(`${this.outdir}/${fileName}`)
    let stream = canvas.createPNGStream();

    stream.on('data', function(chunk){
      out.write(chunk);
    });
  }

  /**
   * Return a color from a palette based on the value,
   * the value will be converted to an index for a palette
   * and the color at the index is returned
   * @param {string} key - the key the palette is store under
   * @param {number} value - the numerical value to convert to a palette index 0..1
   */
  paletteBrush (key, value) {
    let palette = this.palettes[key];
    return palette[Math.floor(value * (palette.length - 1))];
  }

  hslBrush (value) {
    let adj = (1-value)*0.833;
    return this.hslToRgb(adj, 1, 0.5);
  }

  /**
   * Return a color generated by applying the stop rules
   * the value is denormalized into one or more color components
   * the remaining components may be fixed at specific values
   */
  gradBrush (key, value) {
    let index = Math.floor(value * (this.stops[key].length - 1));
    let adjVal = (value * (this.stops[key].length - 1)) - index;

    let stop = this.stops[key][index];
    let red = stop.R;
    let green = stop.G;
    let blue = stop.B;

    if (red === undefined) {
      let change = Math.floor(Math.abs(stop.r * adjVal) * 255);
      red = stop.r > 0 ? change : 255 - change;
    }
    if (green === undefined) {
      let change = Math.floor(Math.abs(stop.g * adjVal) * 255);
      green = stop.g > 0 ? change : 255 - change;
    }
    if (blue === undefined) {
      let change = Math.floor(Math.abs(stop.b * adjVal) * 255);
      blue = stop.b > 0 ? change : 255 - change;
    }
    return {
      r: red,
      g: green,
      b: blue,
      a: 255
    }
  }

  /**
   * Combine two grids
   * TODO
   */
  combine (grid1, grid2) {
    // show temperature overlaid on the map
    if (this.showTemperature) {
      let temperature = elem.temperature;
      let bg = this.heightColorMap[Math.floor(height * 15)];
      let fg = this.tempColorMap[Math.floor(temperature * 7)];
      // blend colors
      color = this.blend(fg, bg);
    }
  }

  /**
   * Blend two rgba colors
   */
  blend (fg, bg) {
    let fga = fg.a/255;
    return {
      r: (fg.r * fga) + (bg.r * (1 - fga)),
      g: (fg.g * fga) + (bg.g * (1 - fga)),
      b: (fg.b * fga) + (bg.b * (1 - fga)),
      a: 255
    };
  }

  /**
   * Set the value at x y to the given color
   * @param {array} data - the image data array
   * @param {number} width - the width of the image data
   * @param {number} x - the x coord
   * @param {number} y - the y coord
   * @param {object} color - the color as {r, g, b, a}
   */
  setPixel (data, width, x, y, color) {
    let offset = ((y * width) + x) * 4;
    data[offset] = color.r;
    data[offset+1] = color.g;
    data[offset+2] = color.b;
    data[offset+3] = color.a;
  }

  /**
   * Converts an HSL color value to RGB. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes h, s, and l are contained in the set [0, 1] and
   * returns r, g, and b in the set [0, 255].
   *
   * @param   Number  h       The hue
   * @param   Number  s       The saturation
   * @param   Number  l       The lightness
   * @return  Object          The RGB representation
   */
  hslToRgb(h, s, l){
      var r, g, b;

      if (s == 0) {
          r = g = b = l; // achromatic
      }
      else {
        var hue2rgb = function hue2rgb(p, q, t){
          if(t < 0) t += 1;
          if(t > 1) t -= 1;
          if(t < 1/6) return p + (q - p) * 6 * t;
          if(t < 1/2) return q;
          if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        }

        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }

      return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255),
        a: 255
      };
  }
}

module.exports = Display;
